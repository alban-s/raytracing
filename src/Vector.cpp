//
// Created by constantin on 11/09/2020.
//

#include "Vector.h"
#include <iostream>
#include <cmath>


/*
template<typename T>
float Vector3<T>::mag() const {
    return sqrtf((this->x* this->x) + (this->y * this->y) + (this->z + this->z));
}
template<typename T>
Vector3<float> Vector3<T>::normalize() {
    return Vector3(*this / this->mag());
}


template<typename T>
Vector3<T> Vector3<T>::operator=(const Vector3<T> &vec) {
    this->x=vec.x;
    this->y=vec.y;
    this->z=vec.z;
    return *this;
}

template<typename T>
Vector3<T> operator+(Vector3<T> from, const Vector3<T> &add) {
    return Vector3(from.x + add.x, from.y + add .y, from.z+add.z);
}

template<typename T>
Vector3<T> operator*(const T n,const Vector3<T> &vec) {
    return Vector3(vec.x*n, vec.y*n, vec.z*n);
}

template<typename T>
Vector3<T> operator*(Vector3<T> &vec, const T &n) {
    return n*vec;
}

template<typename T>
Vector3<T> operator+=(Vector3<T> from, const Vector3<T> &add)  {
    return from + addObject;
}

template<typename T>
Vector3<T> operator/(const Vector3<T> from, const T& n) {
    return Vector3(from.x/n, from.y/n, from.z/n);
}



template<typename T>
float magnitude(const Vector3<T> &vec)  {
    return sqrtf((vec.x * vec.x)+(vec.y*vec.y)+(vec.z*vec.z));
}

template<typename T>
Vector3<float> normalize(const Vector3<T> & vec) {
    return Vector3(vec / magnitude(vec));
}
*/



